# Eurika 2.0 — SPECIFICATION (v0.3 draft)

## 1. Назначение v0.3

v0.3 строится поверх:

- **v0.1** — Architecture Awareness Engine (scan → analyze → explain → log);
- **v0.2** — AgentCore поверх v0.1 (arch_review / arch_evolution_query + feedback).

Цель v0.3:

- добавить **архитектурную приоритизацию**: отвечать не только *“что происходит”* и *“как менялось”*,
  но и *“с чего разумнее начать”*;
- при этом **сохраняется полный read-only режим**:
  - никакого изменения кода,
  - никакого автоматического применения предложений,
  - никакого исполнения.

## 2. Граница возможностей v0.3

### 2.1 Что добавляет v0.3

- новый класс предложений AgentCore:
  - `action="prioritize_modules"` — упорядоченный список модулей / участков кода
    по архитектурному риску / пользе от рефакторинга;
- использование комбинации:
  - smells (из Architecture Awareness Engine),
  - centrality / degree (из графа и summary),
  - истории (architecture_history, при наличии),
  - (опционально) ручного feedback (architecture_feedback.json),
  для построения **детерминированного рейтинга приоритетов**.

### 2.2 Чего v0.3 по-прежнему НЕ делает

- **не** модифицирует код;
- **не** запускает инструменты рефакторинга/форматирования;
- **не** принимает решений самостоятельно:
  - приоритеты = рекомендации, а не план выполнения;
- **не** расширяет домен за пределы:
  - архитектуры самого проекта Eurika (в v0.3 по умолчанию).

Расширение домена (анализ внешних проектов) — отдельный SPEC‑шаг.

## 3. Позиция v0.3 относительно v0.2

v0.2 отвечает на вопросы:

- *“какие риски сейчас?”* (`explain_risk`);
- *“как менялась архитектура во времени?”* (`summarize_evolution`).

v0.3 добавляет:

- *“какие модули/участки трогать в первую очередь?”* (`prioritize_modules`).

Это всё ещё **уровень мышления / планирования**, не исполнения.

## 4. Базовые сущности v0.3

Опираемся на типы из v0.2 (`InputEvent`, `DecisionProposal`, `Result`).

### 4.1 Новое действие: `"prioritize_modules"`

```python
class DecisionProposal:
    action: str          # "explain_risk", "summarize_evolution", "prioritize_modules", ...
    arguments: dict
    confidence: float
    rationale: str
```

Для `action="prioritize_modules"` `arguments` должен содержать:

```python
{
  "modules": [
    {
      "name": "project_graph.py",
      "score": 0.92,                 # агрегированный риск/приоритет
      "reasons": [
        "god_module (high degree)",
        "bottleneck (high fan-in, low fan-out)",
        "central in dependency graph"
      ]
    },
    {
      "name": "architecture_smells.py",
      "score": 0.75,
      "reasons": [...]
    },
    # ...
  ]
}
```

Требования:

- список отсортирован по `score` по убыванию;
- `reasons` опираются на конкретные метрики (smells, centrality, history).

## 5. Входные артефакты для приоритизации

AgentCore v0.3 может использовать:

- `self_map.json`:
  - список модулей / строк / функций / классов,
  - зависимости между модулями;
- `architecture_summary`:
  - центральные модули, syntactic maturity, список рисков;
- `architecture_smells` (через facade `architecture_diagnostics`):
  - список `ArchSmell` с типами (`god_module`, `bottleneck`, `hub`, `cyclic_dependency`) и severity;
- `architecture_history.json` (опционально):
  - тренды сложности / smells / централизации,
  - регрессии;
- `architecture_feedback.json` (опционально):
  - как часто предложения определённого типа/action получали статус `accepted` / `rejected`.

## 6. Алгоритмические требования к `prioritize_modules`

v0.3 **не фиксирует конкретную формулу**, но задаёт рамки:

1. **Прозрачность**  
   - Для каждого модуля должны быть явно указаны `reasons`, из которых видно:
     - какие smells/метрики повлияли,
     - какие исторические тренды учитывались.

2. **Детерминированность**  
   - При одинаковых входных артефактах (self_map, summary, history, feedback) рейтинг должен быть одинаковым.

3. **Локальность решения**  
   - v0.3 **не** строит сложные multi-step планы,
   - ограничивается “списком приоритетов”,
   - не выбирает конкретные рефакторинговые действия.

4. **Учет истории и feedback (если есть)**  
   - История:
     - модули, где:
       - растёт max_degree,
       - растёт общее количество smells,
       - появляются новые циклы,
     могут получать повышенный score;
   - Feedback:
     - если предложения по модулю часто `accepted`, это может повышать доверие к его приоритету;
     - если часто `rejected`, приоритет можно понижать или помечать как спорный.

## 7. Сценарии использования v0.3

### 7.1 Приоритизация модулей после обзора

1. Инженер запускает:

```bash
eurika scan .
eurika agent arch-review .
```

2. Смотрит:
   - `explain_risk`,
   - `summarize_evolution`.
3. Затем вызывает (после реализации CLI):

```bash
eurika agent prioritize-modules .
```

4. Получает:
   - отсортированный список модулей с `score` и `reasons`,
   - использует его как чек-лист для планирования рефакторинга.

### 7.2 Architecture Planner (draft)

В v0.3 появляется отдельный планировщик:

- модуль `architecture_planner.py`:
  - `PlanStep`: отдельный шаг плана (target, kind, priority, rationale, hints);
  - `ArchitecturePlan`: контейнер плана;
  - `build_plan(project_root, summary, smells, history_info, priorities)`:
    - чистая функция, работающая только с диагностикой,
    - в v0.3 может возвращать пустой или минимальный план,
      но фиксирует контракт и формат для будущего развития.

AgentCore может оборачивать результат `build_plan(...)` в `DecisionProposal`
типа `"suggest_refactor_plan"` в будущих версиях.

### 7.3 Feedback loop (расширенный)

v0.3 допускает (опционально):

- после рефакторинга инженер:
  - отмечает, был ли полезен приоритет для конкретного модуля (через `architecture_feedback`),
  - в будущем это может использоваться для корректировки scoring‑эвристик.

Реальное изменение поведения на основе feedback — **за рамками v0.3** и переедет в будущий SPEC.

## 8. Ограничения безопасности v0.3

v0.3 наследует все ограничения из v0.1 и v0.2:

- никакого self-modifying behavior;
- никакого исполнения shell / сети;
- все рекомендации и приоритеты:
  - должны быть воспроизводимы,
  - должны быть объяснимы метриками;
- любые расширения домена (другие проекты, другие языки) требуют:
  - обновления SPEC,
  - пересмотра контрактов безопасности.

## 9. Критерии успеха v0.3

v0.3 можно считать достигнутой, если:

- инженер:
  - может получить **список модулей по приоритету** для архитектурного рефакторинга,
  - понимает, *почему* модуль оказался на конкретном месте (reasons → метрики),
  - может использовать этот список как основу для ручного планирования работ;
- система остаётся:
  - полностью read-only,
  - детерминированной,
  - ограниченной архитектурой проекта Eurika.

